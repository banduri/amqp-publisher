#!/usr/bin/env python

import sys
import subprocess

import logging
import sys
from pprint import pprint,pformat


from amqppublisher import args
from amqppublisher.tools import Timeout, TimeoutException
from amqppublisher.connection import AMQPConnectionBorg
from amqppublisher.messages import getMessageProperties
log = logging.getLogger(__name__)



def main():
  
    try:
        body = None

        with open(args.inputfile,"rb") as fd:
            body = fd.read()


        if args.rpc:
            (ch,con) = AMQPConnectionBorg(args).getConnection()
            result = ch.queue_declare(exclusive=True)
            args.reply_to = result.method.queue

        props = getMessageProperties(args)

        try:
            log.info("try to published Message (%d Bytes): %s" %(len(body),str(props)))
            
            (ch,con) = AMQPConnectionBorg(args).getConnection()

            ch.basic_publish(exchange=args.exchange,
                             routing_key=args.routingkey,
                             properties=props,
                             body=body)
            log.info("done: (%d Bytes): %s" %(len(body),str(props)))
        except Exception as e:
            log.critical("Exception: %s %s" %(type(e),str(e)))
            log.critical("could not published Message (%d Bytes): %s" %(len(body),str(props)))
            
        if args.rpc:

            if args.debug:
                print(args.reply_to)
            # nur an einer Nachricht interressiert, daher next auf das generatorobjekt
            try:
                (ch,con) = AMQPConnectionBorg(args).getConnection()
                with Timeout(args.rpc_timeout):

                    ch.basic_qos(prefetch_count = 1)

                    (method, properties, body) = next(ch.consume(queue = reply_to))
                    if args.rpc_targetfile or args.rpc_callback:
                        if not args.rpc_targetfile:
                            args.rpc_targetfile = "asdf"
                        with open(args.rpc_targetfile,"wb") as fd:
                            fd.write(body)
                    else:
                        # wir gehen einfach davon aus, dass es sich um utf8 handelt
                        sys.stdout.write(str(body,'utf-8'))
                if args.rpc_callback:
                    tmparray = []
                    if properties.headers:
                        for k,v in properties.headers.items():
                            tmparray.append("-h")
                            tmparray.append("%s=%s" %(k,v))

                    log.info(str(properties))
                    commandarray = [args.callbackcommand, 
                                    "-f", str(filename),
                                    "-r", str(method.routing_key),
                                    "-m", str(properties.content_type),
                                    "-e", str(properties.content_encoding),
                                    "-i", str(properties.message_id),
                                    "-p", str(properties.priority),
                                    "-d", str(properties.delivery_mode),
                                    "-c", str(properties.correlation_id),
                                    "-R", str(properties.reply_to),
                                    "-x", str(properties.expiration),
                                    "-y", str(properties.type),
                                    "-u", str(properties.user_id),
                                    "-a", str(properties.app_id),
                                    "-C", str(properties.cluster_id),
                                    "-t", str(properties.timestamp)]
                    commandarray.extend(tmparray)
                    subprocess.check_output(commandarray,timeout=args.rpc_callback_timeout)
                    if not (args.debug or args.rpc_nodelete):
                        os.remove(args.rpc_targetfile)
                ch.basic_ack(delivery_tag = method.delivery_tag)
            except Timeout.Timeout as e:
                raise(e)

    except Timeout.Timeout as e:
        log.critical("Timeout beim warten auf die rpc-nachricht: \n Config:\n %s \n %s" %(pformat(args),pformat(e)))
        sys.exit(2)

    except Exception as e:
        log.critical("Could not send message \n Config:\n %s \n %s" %(pformat(args),pformat(e)))
        sys.exit(3)

    finally:

        # das hier wird 100% ausgefuehrt, auch wenn in dem exception handling vorher
        # schon ein sys.exit hinterlegt ist.

        if AMQPConnectionBorg(args).is_connected():
            (ch,con) = AMQPConnectionBorg(args).getConnection()
            ch.close()
            con.close()

    sys.exit(0)

if __name__ == "__main__":
    main()
    
