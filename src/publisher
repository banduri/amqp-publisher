#!/usr/bin/env python

import pika
import sys
import subprocess
import time
import uuid
import logging
import logging.handlers
import sys
from publisherconf import args, parameters
from amqphelper import pikaversioncheck

pikaversioncheck()

# monkey-patch for python 2.6 
if "check_output" not in dir( subprocess ): # duck punch it in!
    from amqphelper import backward_check_output
    subprocess.check_output = backward_check_output
### end monkey - patch

# make some logging
log=logging.getLogger("AMQPFilePublisher")
if args.verbose:
    logging.basicConfig()
    log.setLevel(logging.INFO)
elif args.debug:
    logging.basicConfig()
    log.setLevel(logging.DEBUG)
    logging.getLogger('pika').setLevel(logging.DEBUG)
    logging.getLogger('pika.callback').setLevel(logging.DEBUG)
    logging.getLogger('pika.adapters.base_connection').setLevel(logging.DEBUG)
else:
    # only critical
    logging.basicConfig(level=logging.CRITICAL)

count = 0
ch = None
while count < args.retry:
    try:
        con=pika.BlockingConnection(parameters)
        ch=con.channel()
        break
    except Exception, e:
        logging.warn("failed to connect to %s (%s/%s); next try in %s seconds (%s)" %(args.host,count,args.retry,args.sleep,e))
        time.sleep(args.sleep)
        count = count + 1
        if ch:
            ch.close()
        if con:
            con.close()
        
if not ch:
    log.critical("AMQP could not connect to server\n Config:\n %s" %str(args))
    sys.exit(1)


try:
    with open(args.inputfile,"rb") as fd:
        body = fd.read()
        mime_type = "application/octet-stream"
        mime_encoding = "binary"
        result = ""
        try:
            # get the mimetype of the file 
            cmd = ['file','-b','--mime',args.inputfile]
            result = subprocess.check_output(cmd)
        except:
            pass

        if not args.mimetype:
            try:
                mime_type = result.split(";")[0].strip()
            except:
                pass
        else:
            mime_type = args.mimetype

        if not args.mimeencoding:
            try:
                mime_encoding = result.split("=")[1].strip()
            except:
                pass
        else:
            mime_encoding = args.mimeencoding

        headerdata = None
        if args.additional_field:
            if not headerdata:
                headerdata={}
            for x in args.additional_field:
                try:
                    (k,v) = x.split("=",1)
                    headerdata[k]=v
                except Exception,e:
                    logging.warning("could not add additional headers %s" %e)

        props = pika.BasicProperties(
            delivery_mode = args.deliverymode,
            content_type = mime_type,
            content_encoding = mime_encoding,
            headers = headerdata,
            priority = args.priority,
            correlation_id = args.correlationid, 
            reply_to = args.replayto,
            expiration = None, 
            message_id = str(uuid.uuid4()), # make a random uuid
            timestamp = int(time.time()),
            type = None, 
            user_id = args.userid,
            app_id = args.appid,
            cluster_id = args.clusterid)    

        count = 0
        while count < args.retry:
            try:
                log.info("try to published Message (%d Bytes): %s" %(len(body),str(props)))
                ch.basic_publish(exchange=args.exchange,
                                 routing_key=args.routingkey,
                                 properties=props,
                                 body=body)
                break
            except:
                if count < args.retry:
                    log.warn("could not published Message (%d Bytes) (%s/%s): %s (%s) retry in (%s) seconds" %(count,args.retry,len(body),str(props),e,args.sleep))
                    time.sleep(args.sleep)
                else:
                    if ch:
                        ch.close()
                    if con:
                        con.close()
                    log.critical("could not published Message (%d Bytes): %s (%s)" %(len(body),str(props),e))
                    sys.exit(1)
                    

        if ch:
            ch.close()
        if con:
            con.close()


except Exception, e:
    log.critical("Could not open messagefile \n Config:\n %s (%s)" %(str(args),e))


